# Complete Yoruba Calendar App with All Features
import os
from flask import Flask, jsonify, render_template, redirect, url_for, request, flash
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from flask_migrate import Migrate
from flask_admin import Admin
from flask_admin.contrib.sqla import ModelView
from datetime import datetime, timedelta
import math
from werkzeug.security import generate_password_hash, check_password_hash
from flask_mail import Mail, Message
import requests
from apscheduler.schedulers.background import BackgroundScheduler
import pytz

# Initialize Flask App
app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'dev-key-123')

# Database Configuration
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///yoruba_calendar.db').replace('postgres://', 'postgresql://')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Email Configuration
app.config['MAIL_SERVER'] = os.getenv('MAIL_SERVER', 'smtp.gmail.com')
app.config['MAIL_PORT'] = int(os.getenv('MAIL_PORT', 587))
app.config['MAIL_USE_TLS'] = os.getenv('MAIL_USE_TLS', 'true').lower() == 'true'
app.config['MAIL_USERNAME'] = os.getenv('MAIL_USERNAME')
app.config['MAIL_PASSWORD'] = os.getenv('MAIL_PASSWORD')
app.config['MAIL_DEFAULT_SENDER'] = os.getenv('MAIL_DEFAULT_SENDER', 'noreply@yorubacalendar.com')

# Initialize Extensions
db = SQLAlchemy(app)
migrate = Migrate(app, db)
mail = Mail(app)
login_manager = LoginManager(app)
admin = Admin(app, name='Od√∫n Admin', template_mode='bootstrap3')

# ======================
# MODELS
# ======================

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    is_admin = db.Column(db.Boolean, default=False)
    email_verified = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_login = db.Column(db.DateTime)
    
    # Relationships
    rituals = db.relationship('UserRitual', backref='user', lazy=True)
    notifications = db.relationship('Notification', backref='user', lazy=True)
    devices = db.relationship('Device', backref='user', lazy=True)
    subscriptions = db.relationship('Subscription', backref='user', lazy=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class UserRitual(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    date = db.Column(db.String(10))  # Format: "MM-DD"
    notes = db.Column(db.Text)
    completed = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Notification(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    title = db.Column(db.String(100))
    message = db.Column(db.Text)
    is_read = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    notification_type = db.Column(db.String(50))  # 'system', 'reminder', 'event'

class Device(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    token = db.Column(db.String(255))
    platform = db.Column(db.String(50))  # 'ios', 'android', 'web'
    last_active = db.Column(db.DateTime)

class Subscription(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    endpoint = db.Column(db.String(512))
    keys = db.Column(db.JSON)  # For WebPush
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class ImportantDate(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    description = db.Column(db.Text)
    month = db.Column(db.Integer)  # Yoruba month (1-13)
    day = db.Column(db.Integer)    # Yoruba day (1-28)
    is_annual = db.Column(db.Boolean, default=True)
    notification_days_before = db.Column(db.Integer, default=1)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

# Admin Views
class AdminModelView(ModelView):
    def is_accessible(self):
        return current_user.is_authenticated and current_user.is_admin

admin.add_view(AdminModelView(User, db.session))
admin.add_view(AdminModelView(UserRitual, db.session))
admin.add_view(AdminModelView(Notification, db.session))
admin.add_view(AdminModelView(Device, db.session))
admin.add_view(AdminModelView(Subscription, db.session))
admin.add_view(AdminModelView(ImportantDate, db.session))

# ======================
# COMPLETE 13-MONTH DATA
# ======================

yoruba_months = [...]  # (Same as previous implementation)

# ==================
# NOTIFICATION SYSTEM
# ==================

def send_email(to, subject, template, **kwargs):
    try:
        msg = Message(
            subject,
            recipients=[to],
            html=render_template(f'emails/{template}.html', **kwargs)
        mail.send(msg)
        return True
    except Exception as e:
        app.logger.error(f"Email sending failed: {str(e)}")
        return False

def send_push_notification(user, title, body, data=None):
    try:
        # WebPush implementation
        from pywebpush import webpush
        for sub in user.subscriptions:
            webpush(
                subscription_info={
                    "endpoint": sub.endpoint,
                    "keys": sub.keys
                },
                data=json.dumps({"title": title, "body": body, **data}),
                vapid_private_key=os.getenv('VAPID_PRIVATE_KEY'),
                vapid_claims={
                    "sub": "mailto:admin@yorubacalendar.com"
                }
            )
        return True
    except Exception as e:
        app.logger.error(f"Push notification failed: {str(e)}")
        return False

def create_notification(user_id, title, message, notification_type='system'):
    notification = Notification(
        user_id=user_id,
        title=title,
        message=message,
        notification_type=notification_type
    )
    db.session.add(notification)
    db.session.commit()
    return notification

# ==================
# SCHEDULED TASKS
# ==================

scheduler = BackgroundScheduler(timezone=pytz.UTC)

def check_daily_events():
    """Check and send notifications for today's events"""
    from datetime import date
    today = date.today()
    
    # Get Yoruba date (simplified conversion)
    yoruba_month = (today.month % 13) + 1
    yoruba_day = today.day % 28 or 28
    
    # 1. Check important dates
    important_dates = ImportantDate.query.filter(
        (ImportantDate.month == yoruba_month) &
        (ImportantDate.day == yoruba_day)
    ).all()
    
    for event in important_dates:
        users = User.query.filter(User.email_verified == True).all()
        for user in users:
            # Email notification
            send_email(
                user.email,
                f"Today: {event.name}",
                'event_notification',
                event=event,
                user=user
            )
            
            # Push notification
            send_push_notification(
                user,
                f"üóìÔ∏è {event.name}",
                event.description[:100]
            )
            
            # In-app notification
            create_notification(
                user.id,
                event.name,
                event.description,
                'event'
            )
    
    # 2. Check user rituals
    today_str = today.strftime("%m-%d")
    rituals = UserRitual.query.filter_by(date=today_str).all()
    for ritual in rituals:
        if not ritual.completed:
            send_push_notification(
                ritual.user,
                "Your Ritual Reminder",
                f"Don't forget: {ritual.notes[:80]}"
            )
            create_notification(
                ritual.user_id,
                "Ritual Reminder",
                ritual.notes,
                'reminder'
            )

scheduler.add_job(
    func=check_daily_events,
    trigger='cron',
    hour=8,
    minute=0
)

# ==================
# AUTHENTICATION
# ==================

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        
        if User.query.filter((User.username == username) | (User.email == email)).first():
            flash('Username or email already exists')
            return redirect(url_for('register'))
        
        user = User(username=username, email=email)
        user.set_password(password)
        db.session.add(user)
        db.session.commit()
        
        # Send verification email
        send_email(
            email,
            "Verify Your Email",
            'verify_email',
            user=user
        )
        
        flash('Registration successful! Please check your email to verify your account.')
        return redirect(url_for('login'))
    
    return render_template('auth/register.html')

@app.route('/verify/<token>')
def verify_email(token):
    # Implement token verification logic
    flash('Email verified successfully!')
    return redirect(url_for('login'))

# ==================
# MAIN APPLICATION
# ==================

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/dashboard')
@login_required
def dashboard():
    today = datetime.now()
    yoruba_date = convert_to_yoruba_date(today)
    month_data = next(m for m in yoruba_months if m['name'] == yoruba_date['month'])
    day_data = month_data['days'][yoruba_date['day'] - 1]
    
    # Get user notifications
    notifications = Notification.query.filter_by(
        user_id=current_user.id,
        is_read=False
    ).order_by(Notification.created_at.desc()).limit(5).all()
    
    # Get today's rituals
    today_str = today.strftime("%m-%d")
    rituals = UserRitual.query.filter_by(
        user_id=current_user.id,
        date=today_str
    ).order_by(UserRitual.created_at.desc()).all()
    
    return render_template('dashboard.html',
                         yoruba_date=yoruba_date,
                         month=month_data,
                         day=day_data,
                         rituals=rituals,
                         notifications=notifications)

# ==================
# API ENDPOINTS
# ==================

@app.route('/api/calendar')
def api_calendar():
    return jsonify({
        'months': [{
            'name': m['name'],
            'orisha': m['orisha'],
            'theme': m['theme']
        } for m in yoruba_months]
    })

@app.route('/api/subscribe', methods=['POST'])
@login_required
def web_push_subscribe():
    subscription = request.json
    sub = Subscription(
        user_id=current_user.id,
        endpoint=subscription['endpoint'],
        keys=subscription['keys']
    )
    db.session.add(sub)
    db.session.commit()
    return jsonify({'success': True})

# ==================
# UTILITY FUNCTIONS
# ==================

def convert_to_yoruba_date(gregorian_date):
    """Convert Gregorian date to Yoruba lunar date (simplified)"""
    # This is a simplified version - real implementation would use astronomical calculations
    month_index = (gregorian_date.month - 1) % 13
    day = gregorian_date.day % 28 or 28
    return {
        'month': yoruba_months[month_index]['name'],
        'day': day,
        'yoruba_day': yoruba_months[month_index]['days'][day - 1]['yoruba_day']
    }

# ==================
# INITIALIZATION
# ==================

@app.before_first_request
def initialize_app():
    db.create_all()
    
    # Create admin user if none exists
    if not User.query.filter_by(is_admin=True).first():
        admin = User(
            username='admin',
            email=os.getenv('ADMIN_EMAIL', 'admin@yorubacalendar.com'),
            is_admin=True,
            email_verified=True
        )
        admin.set_password(os.getenv('ADMIN_PASSWORD', 'admin123'))
        db.session.add(admin)
        db.session.commit()
    
    # Start scheduler
    if not scheduler.running:
        scheduler.start()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)